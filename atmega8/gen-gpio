#!/usr/bin/perl
use strict;
use warnings;

use FindBin qw($Bin $Script);

open C, ">$Bin/avr8gpio.h" or die $!;

print C "#pragma once

#include <avr/io.h>

/*
 * This file was generated by $Script don't edit it, edit the script in stead
 * 
 * The idea is to contain both the port and the pin in a single defined value so
 * everything can be optimized to constants at compile time just like the traditional
 * PORTA, PINA, DDRA.
 * 
 * These are quivalents:
 * 
 * Set direction:
 * DDRA |= 1<<PA1;         GPOUTPUT(GPA1);
 * DDRA &=~ 1<<PA2;        GPINPUT(GPA2);
 * 
 * Write bit:
 * PORTA |= 1<<PA5;        GPSET(GPA5);
 * PORTA &=~ 1<<PA7;       GPCLEAR(GPA7);
 * GPWRITE(GPA7, onoff)
 *
 * Read bit:
 * PINA & 1<<PA3           GPREAD(GPA3)
 * 
 * 
 * If the GP macros are used with constants, then the code generated is exactly the same as the traditional
 * way of doing things, but it's also possible to use variable, in which case the there will be a
 * slight penalty of a couple of shitfts and an add and a bitwise and for each read or write.
 * 
 * The great advantage of doing this is that configuring a specific GPIO port can be done by defining
 * a single constant rather than the 4 needed (PINx, DDRx, PORTx and pin number) when using the traditional
 * approach.
 * 
 */

// Equivalent to PINA, PINB, etc. so PINA is the same as GPPIN(GPA0)
#define GPPIN(port) (*(volatile uint8_t *)((port) >> 3))

// Equivalent to DDRA, DDRB, etc. so DDRB is the same as GPDDR(GPB7) 
#define GPDDR(port) (*(volatile uint8_t *)(((port) >> 3)+1))

// Equivalent to PORTA, PORTB, etc. so PORTC is the same as GPPORT(GPC3)
#define GPPORT(port) (*(volatile uint8_t *)(((port) >> 3)+2))

// The bit value of the pin part
#define GPBV(port) (1 << ((port) & 7))

// Configure the pin as output DDRA |= _BV(PA0) is the same as GPOUTPUT(GPA0)
#define GPOUTPUT(port) GPDDR(port) |= GPBV(port)

// Configure the pin as input DDRA &=~ _BV(PA0) is the same as GPINPUT(GPA0)
#define GPINPUT(port)  GPDDR(port) &=~ GPBV(port)

// Set the output bit PORTA |= _BV(PA0) is the same as GPSET(GPA0)
#define GPSET(port) GPPORT(port) |= GPBV(port)

// Clear the output bit PORTA &=~ _BV(PA0) is the same as GPCLEAR(GPA0)
#define GPCLEAR(port) GPPORT(port) &=~ GPBV(port)

// Write a bit to either 1 or 0
#define GPWRITE(port, on) if (on) {GPSET(port);} else {GPCLEAR(port);}

// Read an input pin PINA & _BV(PA1) is the same as GPREAD(GPA1)
#define GPREAD(port)  (GPPIN(port) & GPBV(port))


";

for my $port ('A'..'Z') {

  print C "#ifdef PIN$port\n";


  for my $pin (0..7) {
    print C "  #ifdef PIN$port$pin
    #define GP$port$pin ((((uint16_t)&PIN$port) << 3) + $pin)
  #endif
";

  }
  
  print C "#endif\n\n";
}


close C;

__DATA__

#define __SFR_OFFSET 0x00
#define _MMIO_BYTE(mem_addr) (*(volatile uint8_t *)(mem_addr))
#define _SFR_IO8(io_addr) _MMIO_BYTE((io_addr) + __SFR_OFFSET)
#define PINB _SFR_IO8(0x04)

